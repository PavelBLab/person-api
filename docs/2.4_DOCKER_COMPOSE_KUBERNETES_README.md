# **Person API Kubernetes Deployment Guide (Person API and PostgreSQL in Kubernetes)**

This guide outlines the steps to set up, configure, and deploy the **Person API** and **PostgreSQL** in a **Kubernetes** cluster. Both services will run inside the Kubernetes environment, making it a fully containerized solution.

## **1. Prerequisites**

Ensure you have the following tools installed on your system:

- **kubectl** (Kubernetes command-line tool)
- **Kubernetes Cluster** (local or any cloud-based Kubernetes provider)
- **Helm** (Kubernetes package manager) â€” Optional, depending on your setup

---

## **2. Kubernetes Deployment for Person Api and PostgreSQL**

This section describes the Kubernetes configuration for deploying **PostgreSQL** in the same cluster as **Person API**. It includes the use of **PersistentVolume** and **PersistentVolumeClaim** to provide persistent storage for the PostgreSQL database.

### **Understanding PersistentVolume and PersistentVolumeClaim**

- **PersistentVolume (PV):** A piece of storage in the cluster that has been provisioned by an administrator or dynamically by Kubernetes. It provides storage resources to pods that need persistence.
- **PersistentVolumeClaim (PVC):** A request for storage by a user. A PVC specifies the desired size and access modes. When a PVC is created, Kubernetes binds it to a suitable PV, allowing a pod to use that storage.

  This setup ensures that even if the PostgreSQL pod is restarted or recreated, the data in the database remains intact because it is stored on persistent storage outside the pod lifecycle.

  ### **PersistentVolume Manifest**

  ```yaml
    apiVersion: v1
    kind: PersistentVolume
    metadata:
      name: person-api-postgres-pv
      labels:
        type: person-api-test
    spec:
      storageClassName: manual
      capacity:
        storage: 100Mi
      accessModes:
        - ReadWriteOnce
      hostPath:
        path: "/mnt/data/postgres"
  ```
  
  ### **PersistentVolumeClaim Manifest**
  
  ```yaml
    apiVersion: v1
    kind: PersistentVolumeClaim
    metadata:
      name: person-api-postgres-pvc
      namespace: person-api-test
    spec:
      storageClassName: manual
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 10Mi
  ```

- The **PersistentVolume** uses the `hostPath` storage type, meaning it mounts storage from the node's filesystem (here, `/mnt/data/postgres`) to the pod.
- The **PersistentVolumeClaim** requests a specific amount of storage (10Mi) with the `ReadWriteOnce` access mode, which allows the volume to be mounted as read-write by a single node.


### **PostgreSQL Deployment Manifest**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-deployment
  namespace: person-api-test
  labels:
    app: postgres
spec:
  replicas: 1
  selector:
    matchLabels:
      app: postgres-deployment
  template:
    metadata:
      labels:
        app: postgres-deployment
    spec:
      containers:
        - name: postgres-deployment
          image: postgres:16.4
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              value: testcase
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: person-api-secret
                  key: DB_USERNAME
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: person-api-secret
                  key: DB_PASSWORD
          volumeMounts:
            - name: container-postgres-storage
              mountPath: /var/lib/postgresql/data
            - name: init-script
              mountPath: /docker-entrypoint-initdb.d/init-db.sh
              subPath: init-db.sh
      volumes:
        - name: container-postgres-storage
          persistentVolumeClaim:
            claimName: person-api-postgres-pvc
        - name: init-script
          configMap:
            name: person-api-config-map  # Script from ConfigMap
```

### **PostgreSQL Service Manifest**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  namespace: person-api-test
  labels:
    app: postgres-service
spec:
  type: LoadBalancer
  selector:
    app: postgres-deployment
  ports:
    - name: postgres-http
      port: 15000
      targetPort: 5432
```

### **Person API Deployment Manifest**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: person-api-deployment
  namespace: person-api-test
  labels:
    app: person-api-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: person-api-deployment
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 25%
      maxUnavailable: 25%
  template:
    metadata:
      labels:
        app: person-api-deployment
    spec:
      imagePullSecrets:
        - name: dockerhub-registry-secret
      containers:
        - name: person-api-container
          image: pavelbr368/abnamro-person-api:0.1.2
          ports:
            - containerPort: 4001
          env:
            - name: SPRING_DATASOURCE_URL
              value: jdbc:postgresql://postgres-service:15000/testcase
            - name: SPRING_DATASOURCE_USERNAME
              valueFrom:
                secretKeyRef:
                  name: person-api-secret
                  key: DB_USERNAME
            - name: SPRING_DATASOURCE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: person-api-secret
                  key: DB_PASSWORD
            - name: SPRING_PROFILES_ACTIVE
              valueFrom:
                configMapKeyRef:
                  name: person-api-config-map
                  key: SPRING_PROFILES_ACTIVE
            - name: SERVER_PORT
              valueFrom:
                configMapKeyRef:
                  name: person-api-config-map
                  key: SERVER_PORT
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 4001
            initialDelaySeconds: 10
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 4001
            initialDelaySeconds: 10
            periodSeconds: 5
```

### **Person API Service Manifest**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: person-api-service
  namespace: person-api-test
  labels:
    app: person-api-service
spec:
  type: LoadBalancer
  selector:
    app: person-api-deployment
  ports:
    - name: person-http
      port: 20000
      targetPort: 4001
```

### **Steps to Deploy Person API and Postgres**

1. **Create Namespace:**

   In the terminal use the following cli command:
   ```
   kubectl create namespace person-api-test
   ```

   Check that person-api-dev namespace successfully created:
   ```
   kubectl get namespace
   ```

2. **In terminal navigate to kubernetes folder.**


3. **Deploy Person API and Postgres:**

   - Apply the Person API and Postgres Deployment and Service manifests as well as all other required resources:
     ```
     kubectl apply -f . --recursive 
     ```

4. **Verify Person API and postgres Deployment**:
   - Check the status of the Person API pods:
     ```
     kubectl get deployment -n person-api-test
     kubectl get pod -n person-api-test
     kubectl get service -n person-api-test
     kubectl get secret -n person-api-test
     kubectl get configmap -n person-api-test
     kubectl get pv -n person-api-test
     kubectl get pvc -n person-api-test
     ```

---

## **4. Accessing Person API and Postgres**

- Go to the browser and type below path to open **swagger**:
    ```
    http://localhost:20000/person-api-documentation
    ```
- The **Person API** will be accessible via the `person-api-service` LoadBalancer. You can retrieve the external IP using:
  ```
  kubectl get services -n person-api-test
  ```

- The **PostgreSQL** service will be accessible within the Kubernetes cluster via the internal hostname `postgres-service.person-api-test.svc.cluster.local` on port `15000`. Use this hostname in your database connection string.
- You can also connect to DB from PgAdmin using hostname ```localhost``` and port ```15000```.
---

## **6. Cleanup**

To remove the resources created in the Kubernetes cluster:

1. **Delete Person API and PostgreSQL Deployments and Services**:
   ```
   kubectl delete deployment --all -n person-api-test
   kubectl delete service --all -n person-api-test
   ```

2. **Delete the Namespace (remove all the resources, except Storage Class and Persistent Volume)**:
   ```
   kubectl delete namespace person-api-test
   ```

3. **Delete the Storage Class and Persistent Volume as they applied on cluster level (if you do not need to store historical postgres data)**:
   ```
   kubectl delete pv person-api-postgres-pv
   kubeclt delete storageclass manual
   ```

---

## **7. Summary of Commands**

1. **Create Namespace**:
   ```
   kubectl create namespace person-api-test
   ```

2. **Deploy All resources in kubernetes folder**:
   ```
   kubectl apply -f . --recursive 
   ```

3. **Check Status of Pods**:
   ```
   kubectl get pods -n person-api-test
   ```

4. **Access External Services**:
   ```
   kubectl get services -n person-api-test
   ```

5. **Cleanup**:
   ```
   kubectl delete namespace person-api-test
   ```